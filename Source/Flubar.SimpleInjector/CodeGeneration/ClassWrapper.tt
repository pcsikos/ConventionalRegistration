<#@ template debug="true" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection" #>
<#@ output extension=".txt" #>
<#@ Assembly Name="$(SolutionDir)Flubar.SimpleInjector\bin\Debug\Flubar.SimpleInjector.dll" #>
<#@ import namespace="Flubar.SimpleInjector.CodeGeneration" #>
<#
	var wrappedType = typeof(DemoClass);
	var className = wrappedType.Name + "Wrapper";
	var namespace2 = wrappedType.Namespace;

	var variableNameName = wrappedType.Name.ToLower();
	var fieldName = "_" + variableNameName;
#>
using <#= wrappedType.Namespace #>

namespace <#= namespace2#>
{
	public class <#= className #>
	{
		private readonly <#=wrappedType.Name#> <#=fieldName#>;

		public <#=className#>(<#= wrappedType.Name #> <#= variableNameName #>)
		{
			<#=fieldName#> = <#= variableNameName #>
		}

<#		
		foreach (var sourceMethod in wrappedType.GetMethods(BindingFlags.Public | BindingFlags.Instance)
                .Where(x => !x.IsSpecialName)
                .Where(x => x.DeclaringType != typeof(object)))
        {
			var hasReturnType = sourceMethod.ReturnType != typeof(void);
			var returnType = hasReturnType ? CodeGenerator.GetSafeTypeName(sourceMethod.ReturnType) : "void";
			var returnStatement = hasReturnType ? "return " : "";
			var typeParameters = (sourceMethod.IsGenericMethod) ? "<" + CodeGenerator.GetTypeParameters(sourceMethod) + ">" : "";
			var methodParamters = string.Join(", ", sourceMethod.GetParameters().Select(x => CodeGenerator.GetSafeTypeName(x.ParameterType) + " " + x.Name).ToArray());
			var genericContraints = CodeGenerator.GetTypeParametersConstrants(sourceMethod);
			var methodArguments = string.Join(", ", sourceMethod.GetParameters().Select(x => x.Name).ToArray());
#>
		public <#=returnType#> virtual <#=sourceMethod.Name + typeParameters #>(<#= methodParamters #>) <#
			if (genericContraints.Any())
			{
				PushIndent("      ");
				WriteLine("");
				foreach(var constraint in genericContraints)
				{
					WriteLine(CurrentIndent + constraint);
				}
				ClearIndent();
			}
		#>
		{
			<#=returnStatement + fieldName #>.<#=sourceMethod.Name#>(<#=methodArguments #>);
		}

<#
		}
		#>
	}
}